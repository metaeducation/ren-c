#
# .travis.yaml contains YAML-formatted (http://www.yaml.org/) build
# instructions for continuous integration via Travis CI
# (http://docs.travis-ci.com/).
#


notifications:
    email: false


language: c


matrix:
    include: 
        # Android5, debug, gcc
        #
        - os: linux
          dist: trusty #gcc on Ubuntu 12.04 does not support sanitizers
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.13.2 DEBUG=asserts STANDARD=c RIGOROUS=no STATIC=yes HOST=arm-eabi FFI="no"

        # Android5, release, gcc
        #
        - os: linux
          dist: trusty #gcc on Ubuntu 12.04 does not support sanitizers
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.13.2 DEBUG=none STANDARD=c RIGOROUS=no STATIC=yes HOST=arm-eabi FFI="no"

        # Linux x86, release, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.4.4 DEBUG=none STANDARD=gnu89 RIGOROUS=yes STATIC=yes TCC=i386-tcc ARCH_CFLAGS=-m32

        # Linux x64, debug, g++
        #
        # !!! Note this binary does not support c++11 completely, it's an old
        # gcc 4.6
        #
        - os: linux
          dist: trusty #gcc on Ubuntu 12.04 does not support sanitizers
          sudo: false #Force new container-based infrastructure.
          language: cpp
          env: OS_ID=0.4.40 DEBUG=asserts STANDARD=c++0x RIGOROUS=yes STATIC=yes TCC=tcc

        # Linux x64, release, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.4.40 DEBUG=none STANDARD=gnu99 RIGOROUS=yes STATIC=yes TCC=tcc

        # Windows x86, release, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.3.1 DEBUG=none TOOLS=i686-w64-mingw32- STANDARD=c RIGOROUS=yes STATIC=yes TCC=i386-win32-tcc TCC_CPP_EXTRA_FLAGS='-I../external/tcc/win32/include -DPVAR=TVAR -DTVAR="extern __attribute__((dllimport))"' HOST=i686-w64-mingw32 ARCH_CFLAGS=-m32
        
        # Windows x64, debug, gcc
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: c
          env: OS_ID=0.3.40 DEBUG=asserts TOOLS=x86_64-w64-mingw32- STANDARD=c RIGOROUS=yes STATIC=yes TCC=x86_64-win32-tcc TCC_CPP_EXTRA_FLAGS='-I../external/tcc/win32/include -DPVAR=TVAR -DTVAR="extern __attribute__((dllimport))"' HOST=x86_64-w64-mingw32

        # Windows x64, debug, g++
        #
        # !!! Note this binary does not support c++11 or above
        #
        - os: linux
          sudo: false #Force new container-based infrastructure.
          language: cpp
          env: OS_ID=0.3.40 DEBUG=asserts TOOLS=x86_64-w64-mingw32- STANDARD=c++ RIGOROUS=yes STATIC=yes TCC=x86_64-win32-tcc TCC_CPP_EXTRA_FLAGS='-I../external/tcc/win32/include -DPVAR=TVAR -DTVAR="extern __attribute__((dllimport))"' HOST=x86_64-w64-mingw32
        
        # OSX x64, debug, gcc
        #
        # TCC currently doesn't quite support OSX yet
        #
        # !!! Also, does not honor GCC's static linking flag for libc.
        #
        - os: osx
          osx_image: xcode8.2
          language: c
          env: OS_ID=0.2.40 DEBUG=asserts STANDARD=c99 RIGOROUS=no STATIC=no

        # OSX x64, debug, g++
        #
        # !!! Can't do all warnings as errors, because the switch for
        # files that end in .c as c++ ("-x c++") is deprecated for some overly
        # prescriptive and annoying reason.
        #
        - os: osx
          osx_image: xcode8.2
          language: cpp
          env: OS_ID=0.2.40 DEBUG=asserts STANDARD=c++14 RIGOROUS=no STATIC=no

        # OSX x64, release, gcc
        #
        # !!! Again, does not honor static linking switch.
        #
        - os: osx
          language: c
          env: OS_ID=0.2.40 DEBUG=none STANDARD=c RIGOROUS=no STATIC=no

env:
    global:
         #
         # travis encrypt AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
         #
         - secure: "Bex3tqrlsnv+t3+AJu6nG8bcbfHXeBNWIUUdcEeyB8gWnWnVuBsC5hTw9cUhEWJchJSsV4LeWVL51harzOQRntszyfjeNvPQozCXbTQVGd1tn5Rpt1QKN9VBK007c+ERj9L8JzFkM2HdeVusYY4Bz5tI883DSJkydyJpJp21mG9i8a17bqJsgBW0JmMsMsdv1ilaeb8/Luo8bn0ObIWTTz+4/6RF4XU9UcWLH7I4HlGb3qufR9chWCX7jTT0SLRkEgfudr+KVrY4xIspiPlVwrKvagnOTFcYLxN4JpGOgn1rnCcOxsWo4kE4dwgXZvEn8W2HJmJhzhAHDLkF0S7YhIDQaScJLwSVECI9xu68V5siWdyhzyrSb2K7V8Mtzryjzq1QueCrRRTj7XLY7sx5OxeP//RVMY0Poil5DdB84nI1wezzmT1kj7dkc1Fr1ZqdYSEfCZNd1v+DeRmAf/N70xUyx1tSxAHD96kjDM3lGILIrlt9RLWdeT0BqxQxzaKCowPVgfztH0nzPcoe1DfNfIhG9mEdjeJfLC7hAgc9Dn0KTo/oSwX/TBsTavV+6SPxH1D4q1xVdY9p4G2hS/N1xaqf7ys4DQOPwWZwvhujwGtto4fy7VMvDtX7jI6++0dJe+baG0DetlHvUGKzWpBJgk02k3mREH+9Ui8f7T9vn8Y="
         
         # travis encrypt AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
         #
         - secure: "IlBRG9mRM0BDtb9ZJDKl4QVRjs/e3KxvjEdVS9e8+PlGq+xMDVGQdje9WOED/bhTcoAYabhLKkXY8YZg6rlVj4ecyjjmZRfPA4D9YVMVHZVNldLX9Ed79Kv95dTvFdn6xl9Tbk/CEqtxfDwcN2hZqv9M3TXN2+sKzny6p4ENc8O7sz0Stb4GyFgPdWSIs4SZv/r8/feMgWiUx+q1NFFarMmFsLtKVuiPIyoU6fGW1zZPyh10jKuhi9GYBStcMHIWqvU+9+jbqchMJT1t/1fyEf0fJokNMH2KXCVDbsu7nKhaVZbIxirLdZNicKfzype1uRgzAB/Crpup+TwnINd17HPSqjCnqntuS+pO0mIRcXVhNSE8TG9S8x4N0pgtKYHKyfAjElmjLwPfoMhu5VlZishn6heeUALbQ7y44YwWwG8EoW4PnRFIGg7V4EjlHJkcmDhJWrZX2hVvSGJ72lFhHXFMcr+VKhXWlmK97XdFAz/c/LlSyyrmKtIE6W5kwhJC8bbrpETA/wQ9pP3WEVY28bka24LqI1g0hiDn7cyXae7Ikss36Y8eB/9/00EovCPHw1o+dyenXI10Q8+yorQ42xrjo1bXuYRohCvI+FmV4XFLkJ+c6wDTSKhJTcUhZsQva2F0ipeyqhGQQGkLiZ8BvdoSPHHBx2odikgho9VQZ48="
 
         - AWS_S3_BUCKET_NAME: "metaeducation"


addons:
    apt:
        packages:
            #
            # For building 32b binaries on a 64b host (not necessary when we
            # build for 64b):
            #
            - gcc-multilib
            - g++-multilib

            # For cross-compiling to Windows.
            #
            - binutils-mingw-w64-i686
            - binutils-mingw-w64-x86-64
            - gcc-mingw-w64-i686
            - gcc-mingw-w64-x86-64
            - g++-mingw-w64-i686
            - g++-mingw-w64-x86-64
            - mingw-w64

            # for makeinfo, required to build FFI
            - texinfo


install:
    #
    # Fetch a Rebol bootstrap binary, which is needed for building Rebol.
    # Travis uses the last r3-alpha that was ever published on rebol.com
    # in order to ensure that still works.
    #
    - if [[ "$TRAVIS_OS_NAME" == "linux" ]]; then wget  http://www.rebolsource.net/downloads/experimental/r3-linux-x64-gbf237fc-static && cp r3-linux-x64-gbf237fc-static make/r3-make; fi
    - if [[ "$TRAVIS_OS_NAME" == "osx" ]]; then wget http://rebolsource.net/downloads/experimental/r3-osx-x64-gbf237fc && cp r3-osx-x64-gbf237fc make/r3-make; fi
    - chmod +x make/r3-make

script:
    # Nice to know what version of gcc this is
    - ${TOOLS}gcc --version

    - TOP_DIR=${PWD}
    - |
      if [[ ${OS_ID} = "0.13.2" || ${OS_ID} = "0.13.1" ]]; then
          if [ `uname -m` = x86_64 ]; then wget https://github.com/giuliolunati/android-travis/releases/download/v1.0.0/android-ndk-r13.tgz; ANDROID_NDK=$TOP_DIR/android-ndk-r13; else exit 1; fi
          tar zxf android-ndk-r13.tgz
          echo $PWD
          ls -dl $PWD/android-ndk-r13
          export TOOLS=$ANDROID_NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64/bin/arm-linux-androideabi-
          export EXTRA_CC_FLAGS="--sysroot=$ANDROID_NDK/platforms/android-19/arch-arm"
      fi
      if [[ ${OS_ID} = "0.3.40" || ${OS_ID} = "0.3.1" ]]; then
          # Use prebuilt binaries
          if [[ ${OS_ID} = "0.3.40" ]]; then
              export PKG_CONFIG_PATH=${TOP_DIR}/external/ffi-prebuilt/lib64/pkgconfig
          else
              export PKG_CONFIG_PATH=${TOP_DIR}/external/ffi-prebuilt/lib32/pkgconfig
          fi
          # --define-prefix would be better, but it is not recognized
          export PKGCONFIG="pkg-config --define-variable=prefix=${TOP_DIR}/external/ffi-prebuilt"
          # check cflags and libs
          ${PKGCONFIG} --cflags libffi
          ${PKGCONFIG} --libs libffi
      elif [[ -z ${FFI} || ${FFI} != "no" ]]; then
          # Build libffi
          mkdir build
          cd external/libffi
          ./autogen.sh
          cd ${TOP_DIR}/build
          if [[ -z ${HOST} ]]; then
              ${TOP_DIR}/external/libffi/configure --prefix=$PWD/fakeroot CFLAGS=${ARCH_CFLAGS}
          else #cross-compiling
              ${TOP_DIR}/external/libffi/configure --prefix=$PWD/fakeroot --host=${HOST}
          fi
          make
          make install
          export PKG_CONFIG_PATH=$PWD/fakeroot/lib/pkgconfig
          # check cflags and libs
          pkg-config --cflags libffi
          pkg-config --libs libffi

          ls `pkg-config --variable=toolexeclibdir libffi`
          #remove dynamic libraries to force it to link with static libraries
          rm -f `pkg-config --variable=toolexeclibdir libffi`/*.so*
          rm -f `pkg-config --variable=toolexeclibdir libffi`/*.dylib*
          rm -f `pkg-config --variable=toolexeclibdir libffi`/*.dll*
          ls `pkg-config --variable=toolexeclibdir libffi`
      fi

    - cd ${TOP_DIR}/make/

    # Build TCC
    - |
      if [[ ! -z ${TCC} ]]; then
          mkdir tcc
          cd tcc
          if [[ ${OS_ID} != "0.4.40" ]]; then
              #generate cross-compiler (on x86_64 host and target for i386)
              echo "Generating the cross-compiler"
              ${TOP_DIR}/external/tcc/configure --enable-cross --extra-cflags="-DEMBEDDED_IN_R3"
              make
              mkdir bin
              cp *tcc bin #save cross-compilers
              ls bin/ #take a look at the cross-compilers
              make clean
              #generate libtcc.a
              # libtcc.a requires --enable-mingw32, or it doesn't think it's a native compiler and disables tcc_run
              echo "Generating libtcc.a"
              if [[ ${OS_ID} = "0.4.4" ]]; then
                  ${TOP_DIR}/external/tcc/configure --cpu=x86 --extra-cflags="-DEMBEDDED_IN_R3 ${ARCH_CFLAGS}"
              elif [[ ${OS_ID} == "0.3.1" ]]; then #x86-win32
                  ${TOP_DIR}/external/tcc/configure --cpu=x86 --extra-cflags="-DEMBEDDED_IN_R3" --enable-mingw32 --cross-prefix=${TOOLS}
              else #x86_64-win32
                  ${TOP_DIR}/external/tcc/configure --enable-mingw32 --cpu=x86_64 --extra-cflags="-DEMBEDDED_IN_R3" --cross-prefix=${TOOLS}
              fi
              make libtcc.a && cp libtcc.a libtcc.a.bak

              #generate libtcc1.a
              # --enable-mingw32 must be turned off, or it will try to compile with tcc.exe
              make clean

              echo "Generating libtcc1.a"
              if [[ ${OS_ID} = "0.4.4" ]]; then
                  ${TOP_DIR}/external/tcc/configure --cpu=x86 --extra-cflags="-DEMBEDDED_IN_R3 ${ARCH_CFLAGS}"
              elif [[ ${OS_ID} == "0.3.1" ]]; then #x86-win32
                  ${TOP_DIR}/external/tcc/configure --cpu=x86 --extra-cflags="-DEMBEDDED_IN_R3" --cross-prefix=${TOOLS}
              else #x86_64-win32
                  ${TOP_DIR}/external/tcc/configure --cpu=x86_64 --extra-cflags="-DEMBEDDED_IN_R3" --cross-prefix=${TOOLS}
              fi

              echo "make libtcc1.a"
              make libtcc1.a XCC=${TOOLS}gcc XAR=${TOOLS}ar || echo "ignoring error in building libtcc1.a" #this could fail to build tcc due to lack of '-ldl' on Windows
              cp bin/* . #restore cross-compilers, libtcc1.a depends on tcc
              touch tcc #update the timestamp so it won't be rebuilt
              echo "ls"
              ls #take a look at files under current directory
              echo "make libtcc1.a"
              make libtcc1.a XCC=${TOOLS}gcc XAR=${TOOLS}ar

              echo "Looking for symbol r3_tcc_alloca"
              if [[ ${OS_ID} == "0.3.1" ]]; then #x86-win32
                ${TOOLS}objdump -t lib/i386/alloca86.o |grep alloca
              elif [[ ${OS_ID} == "0.3.40" ]]; then
                ${TOOLS}objdump -t lib/x86_64/alloca86_64.o |grep alloca
              fi

              #restore libtcc.a
              # make libtcc1.a could have generated a new libtcc.a
              cp libtcc.a.bak libtcc.a
          else
              ${TOP_DIR}/external/tcc/configure --extra-cflags="-DEMBEDDED_IN_R3 ${ARCH_CFLAGS}"
          fi
          make
          cd ${TOP_DIR}/make
      fi

    # Grab the abbreviated and full git commit ID into environment variables.
    # The full commit is passed to make to build into the binary, and the
    # abbreviated commit is used to name the executable.
    #
    # http://stackoverflow.com/a/42549385/211160
    #
    - GIT_COMMIT="$(git show --format="%H" --no-patch)" 
    - echo ${GIT_COMMIT}
    - GIT_COMMIT_SHORT="$(git show --format="%h" --no-patch)" 
    - echo ${GIT_COMMIT_SHORT}

    # Take a look at assert.h
    # - find /usr/include -name assert.h | xargs cat
    
    # We have to set REBOL_TOOL explicitly to circumvent the automatic r3-make
    # filename inference, as we always use Linux "r3-make" (not "r3-make.exe")
    # even when doing windows builds, since this is a cross-compilation.
    #
    # As an extra step to test bootstrap ability, we make the 64-bit debug
    # build go even further by doing another full build, but using the 
    # just built r3 as its own r3-make.
    #
    - |
      if [[ ("${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.2.40") && "${DEBUG}" != "none" ]]; then
          #
          # If building twice, don't specify GIT_COMMIT for the first build.
          # This means there's a test of the build process when one is not
          # specified, in case something is broken about that.  (This is how
          # most people will build locally, so good to test it.)
          #
          # Also request address sanitizer to be used for the first build.  It
          # is very heavyweight and makes the executable *huge* and slow, so
          # we do not apply it to any of the binaries which are uploaded to s3
          # -- not even debug ones.
          #
          make -f makefile.boot REBOL_TOOL=r3-make STANDARD="${STANDARD}" OS_ID="${OS_ID}" RIGOROUS="${RIGOROUS}" DEBUG=sanitize STATIC=no

          rm r3-make;
          mv r3 r3-make;
          make clean;
          export R3_ALWAYS_MALLOC=1
      fi

    # On the second build of building twice, or just building once, include
    # the GIT_COMMIT
    #
    -  if [[ -z ${FFI} ]]; then FFI="dynamic"; fi
    - |
      if [[ -z ${TCC} ]]; then
          make -f makefile.boot REBOL_TOOL=r3-make STANDARD="${STANDARD}" OS_ID="${OS_ID}" DEBUG="${DEBUG}" GIT_COMMIT="${GIT_COMMIT}" RIGOROUS="${RIGOROUS}" STATIC="${STATIC}" WITH_FFI=${FFI} WITH_TCC="no"
      else
          make -f makefile.boot REBOL_TOOL=r3-make STANDARD="${STANDARD}" OS_ID="${OS_ID}" DEBUG="${DEBUG}" GIT_COMMIT="${GIT_COMMIT}" RIGOROUS="${RIGOROUS}" STATIC="${STATIC}" WITH_FFI=${FFI} WITH_TCC="${PWD}/tcc/${TCC}"
      fi

    # take a look at the preprocess header file
    # - cat ../src/include/sys-core.i || true

    # output the needed libraries
    - |
      if [[ "${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.4.4" ]]; then
          ldd ./r3
      elif [[ "${OS_ID}" = "0.2.40" ]]; then
          otool -L ./r3
      fi

    # Run once but don't pipe output, in case it prints out useful crash msg
    # that we want to see in the Travis log (especially helpful for failures
    # only happening in the Travis builds that aren't reproducing locally)
    # Save the exit code ($?) so we can return it to Travis as last step
    #
    # !!! This is a very minimal sanity check to ensure the built R3 does
    # *something*, and it can obviously only be used on the linux version.
    # Running the full test suite would be a bit much, and developers are
    # expected to have already done that.  But doing an HTTPS read exercises
    # a fair amount of code.
    #
    - |
      if [[ "${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.4.4" || "${OS_ID}" = "0.2.40" ]]; then
          ./r3 --do "print {Testing...} quit/with either find to-string read https://example.com {<h1>Example Domain</h1>} [0] [1]";
          R3_EXIT_STATUS=$?;
      else
          R3_EXIT_STATUS=0;
      fi
    - echo ${R3_EXIT_STATUS}
    
    # Run basic testing with FFI, this is a linux-only script
    - |
      if [[ "${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.4.4" ]]; then
          ./r3 ../tests/misc/qsort_r.r
          R3_EXIT_STATUS=$?;
      else
          R3_EXIT_STATUS=0;
      fi
    - echo ${R3_EXIT_STATUS}

    # Run basic testing with user natives
    - |
      if [[ ! -z "$TCC" && "$TCC" != "no" && ( "${OS_ID}" = "0.4.40" || "${OS_ID}" = "0.4.4" ) ]]; then
          ./r3 ../tests/misc/fib.r
          R3_EXIT_STATUS=$?;
      else
          R3_EXIT_STATUS=0;
      fi
    - echo ${R3_EXIT_STATUS}

    # Clean Android elf executable
    - |
      if [[ ${OS_ID} = "0.13.2" || ${OS_ID} = "0.13.1" ]]; then
          $ANDROID_NDK/android-elf-cleaner r3
      fi

    # Delete the obj file directory so we don't upload those to S3
    #
    - rm -rf objs
    
    - rm -f makefile*
    - rm -f Toolchain*
    - rm r3-make*
    - rm -f CMakeLists.txt
    - rm -rf tcc
    
    # Name the executable based on the abbreviated commit, whether it is a
    # debug or release build, and if it was built using C++ or not.  Note that
    # the C++ debug builds have additional runtime checks in the debug
    # build...though there should not be any impact on the release build.
    # (Though there may be additional DLL dependencies regardless.)
    #
    # !!! All Ren-C stakeholders should be using debug builds at this time.  
    #
    # Note: -z tests if a variable is undefined
    #
    - NEW_NAME=${OS_ID}/r3-${GIT_COMMIT_SHORT}
    - if [[ "${DEBUG}" != "none" ]]; then NEW_NAME+="-debug"; fi
    - |
      if [[ "${STANDARD}" = "c++" || "${STANDARD}" = "c++0x" || "${STANDARD}" = "c++11" || "${STANDARD}" = "c++14" || "${STANDARD}" = "c++17" ]]; then
          NEW_NAME+="-cpp";
      fi
    - echo ${NEW_NAME}

    # Move the executable into a directory based on its OS_ID platform.
    # This is because the deploy step is run for each OS and would
    # otherwise overwrite executables in the same location.
    #
    - mkdir ${OS_ID}
    - |
      if [[ -e "r3.exe" ]]; then
           mv r3.exe ${NEW_NAME}.exe;
      else
           mv r3 ${NEW_NAME};
      fi

    # Return whether the build succeeded or not to Travis.  If this succeeded 
    # then the deploy step to S3 will run
    #
    # http://stackoverflow.com/a/10457902/211160
    #
    - (exit ${R3_EXIT_STATUS})


# After everything is finished (e.g. script section above), upload build 
# product to Amazon S3.  For how the configuration works and manages to keep
# the private key secure, see:
#
# http://stackoverflow.com/a/42547424/211160
#
deploy:
    provider: s3
    access_key_id: $AWS_ACCESS_KEY_ID
    secret_access_key: $AWS_SECRET_ACCESS_KEY
    bucket: $AWS_S3_BUCKET_NAME
    skip_cleanup: true
    upload-dir: travis-builds
