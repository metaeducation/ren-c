//
//  file: %enum-types.h
//  summary: -[Safe wrapper for distinguishing "Heart" and "Type" if C++]-
//  project: "Rebol 3 Interpreter and Run-time (Ren-C branch)"
//  homepage: https://github.com/metaeducation/ren-c/
//
//=////////////////////////////////////////////////////////////////////////=//
//
// Copyright 2012 REBOL Technologies
// Copyright 2012-2025 Ren-C Open Source Contributors
// REBOL is a trademark of REBOL Technologies
//
// See README.md and CREDITS.md for more information
//
// Licensed under the Lesser GPL, Version 3.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.gnu.org/licenses/lgpl-3.0.html
//
//=////////////////////////////////////////////////////////////////////////=//
//
// There is a basic idea in the system that tests like Is_Word() or WORD? do
// not consider quoted words (or quasi-words, or anti-words) to be "Word".
// They may have a cell layout and payload that carries a symbol and a binding
// like a word, but should not be confused with them.
//
// This distinction has led to a difference in considering the "Type_Of()" of
// a cell in comparison with the "Heart_Of()".  If you ask a word at any
// quoting level what the heart of the cell is, it will say TYPE_WORD.  But
// only a word at the NOQUOTE_1 quoting level will respond with TYPE_WORD to
// Type_Of().  Otherwise it gives TYPE_QUOTED, TYPE_QUASIFORM, or an antiform
// byte (like TYPE_SPLICE, TYPE_TRIPWIRE, etc.)
//
// This means that the extra "types" generated by quoting states are not
// "cell hearts" describing their layout, but a sort of "pseudotype".  It
// would be incorrect to put these values into a cell's heart, and it's also
// make-work to check for them when you're sure you're dealing with something
// that is constrained to being a valid cell heart.
//
// Hence, only some TYPE_XXX values can be written into HEART_BYTE():
//
//    HEART_BYTE(cell) = TYPE_INTEGER;  // valid
//    HEART_BYTE(cell) = TYPE_QUOTED;  // invalid, it's a pseudotype
//
// And you shouldn't really be comparing Heart against pseudotypes:
//
//    void Some_Function(Heart heart) {
//       if (heart == TYPE_QUOTED)  // invalid, it's a pseudotype
//         { ... }
//    }
//
// But to make a long story short, the desire to use the TYPE_XXX values
// in switch() statements is a thorny one.  C++ doesn't have enum inheritance.
// So you either have two enums with overlapping values (e.g. HEART_INTEGER
// in the HeartEnum, and TYPE_INTEGER in the TypeEnum), or you have two enums
// that spread TYPE_XXX values across the enums...and hope the compiler lets
// you get away with lax conversions between them.
//
// Using a enums with redundancy (HEART_INTEGER/TYPE_INTEGER) is the least
// dodgy way to do it.  But it means that if you change between switch(type)
// and switch(heart) you need to rename all your case labels.  It's also
// cleaner reading if people only have to see TYPE_XXX constants.  So for
// now, this goes the hard road of only using TYPE_XXX constants.
//
// The only way to do static analysis to stop the invalid bytes is to make
// HEART_BYTE() a macro that creates a C++ class that holds onto the cell,
// and has an assignment operator that does the desired check before it
// writes the byte to the intended location.  In order to do this, TYPE_XXX
// values can't be "plain" C enums, because there's no way to overload
// them distinctly.  They have to be a class, or an "enum class".
//
// Only MSVC is willing to ignore the C++ standard and allow you to switch()
// on mixed enum class values.  So even though TYPE_INTEGER comes from the
// HeartEnum and TYPE_QUOTED comes from the TypeEnum, you can mix and match
// them in a switch().  So only MSVC is able to statically prevent non-heart
// assignments to HEART_BYTE(), or comparisons of Pseudotypes against literal
// heart TYPE_XXX enum states.
//
// GCC won't interconvert enum classes, which rules out that ability.  But
// it does allow the minor (but useful) prevention of passing a Type where
// a Heart is expected.  It also stops (Heart_Of(cell) == TYPE_QUOTED) types
// of mistakes.
//
// Clang doesn't allow any of it, so just forget it.
//
// 1. The technique requires splitting the enum into two parts (where the
//    TypeEnum has dummy values to cover the HeartEnum cases so that switch()
//    statements on a TypeEnum doesn't trigger a warning checking against
//    TYPE_XXX integral values that it doesn't have an integer for).  But
//    if you're not using the classes there are enum comparison errors.
//    A consolidated enum seems to have to be used if you're not going to
//    be doing the class trick.
//
// 2. All extension types use the 0 byte for their heart.  This means that
//    you can't say (Type_Of(cell1) == Type_Of(cell2)) and get a correct
//    answer in the case of extension types.  To avoid that problem, we
//    have Type_Of() return an Optional(Type), which we then prohibit the
//    comparison of Option(Type) to Option(Type).  You can still compare an
//    unwrapped Type to an Option(Type).
//

#include "tmp-hearts.h"  // HeartEnum and TypeEnum (TYPE_BLOCK, TYPE_TEXT...)

#if (! DEBUG_EXTRA_HEART_CHECKS)
    typedef TypeEnum HeartEnum;

    typedef HeartEnum Heart;  // avoid enum compare warnings [1]
    typedef TypeEnum Type;
#else
    struct Heart {
        HeartEnum h;  // an "enum class" in MSVC (members are HeartEnum::XXX)

        Heart () = default;
        Heart (HeartEnum heart) : h (u_cast(HeartEnum, heart)) {}
        explicit Heart (Byte byte) : h (u_cast(HeartEnum, byte)) {}
        explicit Heart (SymId id) {
            assert(id <= u_cast(Byte, MAX_HEART));
            h = u_cast(HeartEnum, id);
        }

        explicit operator bool() const  // for Option(Heart) in if() statements
          { return cast(Byte, h) != 0; }

        explicit operator Byte() const
          { return u_cast(Byte, h); }

        explicit operator SymId() const
          { return u_cast(SymId, h); }

        explicit operator uintptr_t() const
          { return u_cast(uintptr_t, h); }

        operator HeartEnum() const
          { return h; }
    };

    struct Type {
        TypeEnum t;  // an "enum class" in MSVC (members are TypeEnum::XXX)

        Type () = default;
        Type (HeartEnum heart) : t (u_cast(TypeEnum, heart)) {}
        Type (const Heart& heart) : t (u_cast(TypeEnum, heart.h)) {}
        Type (TypeEnum type) : t (type) {}
        explicit Type (Byte byte) : t (u_cast(TypeEnum, byte)) {}
        explicit Type (SymId id) {
            assert(id <= MAX_TYPE_BYTE);
            t = u_cast(TypeEnum, id);
        }

        explicit operator bool() const  // for Option(Type) in if() statements
          { return cast(Byte, t) != 0; }

        explicit operator Byte() const
          { return u_cast(Byte, t); }

        explicit operator SymId() const
          { return u_cast(SymId, t); }

        explicit operator uintptr_t() const
          { return u_cast(uintptr_t, t); }

        operator TypeEnum() const
          { return t; }
    };

    // Disable comparing literally against elements from TypeEnum, e.g.
    //
    //     if (heart == TYPE_QUOTED) { ... }  // cause an error
    //
    // This doesn't stop comparing Type variables to Heart variables, which
    // is considered to be valid.  (Should it be?)

    template <typename T, EnableIfSame<T, TypeEnum> = nullptr>
    INLINE bool operator==(const Heart& heart, T&& t) = delete;

    template <typename T, EnableIfSame<T, TypeEnum> = nullptr>
    INLINE bool operator==(T&& t, const Heart& heart) = delete;

    template <typename T, EnableIfSame<T, TypeEnum> = nullptr>
    INLINE bool operator!=(const Heart& heart, T&& t) = delete;

    template <typename T, EnableIfSame<T, TypeEnum> = nullptr>
    INLINE bool operator!=(T&& t, const Heart& heart) = delete;

    // If using enum classes, things get complicated.  Because there are
    // non-explicit conversions betwen the two types, it's a hodgepodge of
    // default behaviors that become ambiguous with the overloads.  Without
    // overloads it won't work, but with overloads it doesn't work either.
    // You have to add the overloads and then use SFINAE to disable very
    // narrow cases of ambiguity.  This is a bit of a mess, but it works.

  #if defined(_MSC_VER)
    INLINE bool operator==(Heart& left, Heart& right)
      { return u_cast(Byte, left.h) == u_cast(Byte, right.h); }

    INLINE bool operator!=(Heart& left, Heart& right)
      { return u_cast(Byte, left.h) != u_cast(Byte, right.h); }

    INLINE bool operator==(Type& left, Type& right)
      { return u_cast(Byte, left.t) == u_cast(Byte, right.t); }

    INLINE bool operator!=(Type& left, Type& right)
      { return u_cast(Byte, left.t) != u_cast(Byte, right.t); }

    // Very narrow equality tests, only applying to literal HeartEnum values.

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator==(const Heart& heart, T&& h)
      { return heart.h == h; }

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator==(T&& h, const Heart& heart)
      { return h == heart.h; }

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator!=(const Heart& heart, T&& h)
      { return heart.h != h; }

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator!=(T&& h, const Heart& heart)
      { return h != heart.h; }

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator==(const Type& type, T&& h)
      { return u_cast(Byte, type.t) == u_cast(Byte, h); }

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator==(T&& h, const Type& type)
      { return u_cast(Byte, h) == u_cast(Byte, type.t); }

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator!=(const Type& type, T&& h)
      { return u_cast(Byte, type.t) != u_cast(Byte, h); }

    template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
    INLINE bool operator!=(T&& h, const Type& type)
      { return u_cast(Byte, h) != u_cast(Byte, type.t); }

    // Comparisons for TypeEnum and Type (not needed for Heart, it implicitly
    // converts to HeartEnum which is able to compare with other HeartEnum).
    // Because Heart can become a type, this covers Type and Heart comparisons
    // as well as Type and Type comparisons.

    INLINE bool operator>=(const Type& type, TypeEnum t)
      { return type.t >= t; }

    INLINE bool operator>=(TypeEnum t, const Type& type)
      { return t >= type.t; }

    INLINE bool operator<=(const Type& type, TypeEnum t)
      { return type.t <= t; }

    INLINE bool operator<=(TypeEnum t, const Type& type)
      { return t <= type.t; }

    INLINE bool operator>(const Type& type, TypeEnum t)
      { return type.t > t; }

    INLINE bool operator>(TypeEnum t, const Type& type)
      { return t > type.t; }

    INLINE bool operator<(const Type& type, TypeEnum t)
      { return type.t < t; }

    INLINE bool operator<(TypeEnum t, const Type& type)
      { return t < type.t; }
  #endif
#endif


//=//// CUSTOM DATATYPE HEART (0) /////////////////////////////////////////=//
//
// There are a finite number of builtin datatypes (hearts and pseudotypes),
// and then some builtin sparse and ranged typesets.  The sum of all of these
// is up to 255 before running up against an implementation barrier.
//
// So extension types all use the same heart value of 0.  This means that the
// actual extension type's information is stored in the Cell's "extra" slot.
//
// The choice of 0 is purposeful.  It means that Type can be tested for
// quickly in an if() statement to see if the type is not built in, and it
// can work with the Option() wrapper in the C++ build to do systemic type
// checking that differentiates places that haven't checked if the type is
// built in or not.
//
// 1. The enum value is called TYPE_0, but it's legal to in the preprocessor
//    define TYPE_0 to add the extra safety of the Option().  This is good
//    because it helps stop people from using the raw TYPE_0 value without
//    the protections.  (You can't omit the value 0 in the enum, or that can
//    cause problems, so it's best to overwrite the unsafe value via a
//    preprocessor define.)  HEART_ENUM(0) can be used in the rare cases where
//    you want the raw value and don't want to just say "0".
//
// 2. Disabling comparison of Option(Heart) and Option(Type) with each other
//    helps avoid the false positives of extension types comparing as equal:
//
//        if (Type_Of(cell) == Type_Of(other_cell)) { ... }
//
//    The problem is that all extension types are TYPE_0, so they all would
//    compare equal if this were allowed.  Thankfully the C++ build lets
//    us catch this case at compile time.
//
#define TYPE_0 /* #define w/same name as enum TYPE_0 sneaky but legal [1] */ \
    u_cast(Option(Heart), u_cast(HeartEnum, 0))

#if CHECK_OPTIONAL_TYPEMACRO  // make safe for extension types [2]
    bool operator==(Option(Type)& a, Option(Type)& b) = delete;
    void operator!=(Option(Type)& a, Option(Type)& b) = delete;

  #if DEBUG_EXTRA_HEART_CHECKS  // in this mode, Heart is distinct from Type
    bool operator==(Option(Heart)& a, Option(Heart)& b) = delete;
    bool operator!=(Option(Heart)& a, Option(Heart)& b) = delete;

    #if defined(_MSC_VER)
        template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
        INLINE bool operator==(const Option(Type)& a, T b)
          { return u_cast(Byte, maybe a) == u_cast(Byte, b); }

        template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
        INLINE bool operator==(T a, const Option(Type)& b)
          { return u_cast(Byte, a) == u_cast(Byte, maybe b); }

        template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
        INLINE bool operator!=(const Option(Type)& a, T b)
          {  return u_cast(Byte, maybe a) != u_cast(Byte, b); }

        template <typename T, EnableIfSame<T, HeartEnum> = nullptr>
        INLINE bool operator!=(T a, const Option(Type)& b)
          {  return u_cast(Byte, a) != u_cast(Byte, maybe b); }
    #endif
  #endif
#endif


//=//// SINGLEHEART OPTIMIZED SEQUENCE TYPE ///////////////////////////////=//
//
// In Ren-C, `/foo` is a 2-element PATH! with a space at the head, and `bar:`
// is a 2-element CHAIN! with a space at the tail.  Due to how common these
// are, and the fact that they are immutable sequences, there is investment
// in optimizing them.  They are called "SingleHeart" sequences, and because
// detection of these is so common there's a special type which multiplexes
// both the Heart and whether there is a space at the head or tail.
//
// (It's encoded in a single type, because if the leading space or trailing
// space were separated from the heart type, you could accidentally check
// the leading space or trailing space without verifying a sequence was a
// single hearted type.  Static analysis caught bugs of that kind, and they
// are easy to make.)
//
// (See notes on SingleHeart definition for more...)

#define Leading_Space_And(heart) \
    u_cast(SingleHeart, (u_cast(Byte, heart) << 8) + 1)

#define Trailing_Space_And(heart) \
    u_cast(SingleHeart, u_cast(Byte, heart) << 8)

#define LEADING_SPACE_AND(name)     Leading_Space_And(TYPE_##name)
#define TRAILING_SPACE_AND(name)    Trailing_Space_And(TYPE_##name)

INLINE bool Singleheart_Has_Leading_Space(SingleHeart single) {
    assert(single != NOT_SINGLEHEART_0);
    return did (u_cast(uint_fast16_t, single) & 1);
}

#define Singleheart_Has_Trailing_Space(single) \
    (not Singleheart_Has_Leading_Space(single))

INLINE Heart Heart_Of_Singleheart(SingleHeart single) {
    assert(single != NOT_SINGLEHEART_0);
    HeartEnum heart = u_cast(HeartEnum, u_cast(uint_fast16_t, single) >> 8);
    assert(heart != TYPE_0 and heart != TYPE_RUNE);
    return heart;
}
