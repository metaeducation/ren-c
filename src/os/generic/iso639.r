REBOL []

inp: %ISO-639-2_utf-8.txt
cnt: read inp
if #{EFBBBF} = to binary! copy/part cnt 3 [ ;UTF8 BOM
    cnt: skip cnt 3
]

;cnt: to string! cnt
;print ["string cnt BOM:" mold copy/part cnt 3]

lower: charset [#"a" - #"z"]
letter: charset [#"a" - #"z" #"A" - #"Z"]
header: {
    /*
    DO NOT EDIT
    Generated by rebol3 locale.r
    */
    /*  An alpha-3 (bibliographic) code, an alpha-3 (terminologic) code (when given), an alpha-2 code (when given), an English name, and a French name */
    const char* iso_639_table[][5] = ^{
}
outp: %iso-639.h
write outp header
emit: func [cnt] [
    ;print ["writing" cnt]
    write/append outp cnt
]

binary-to-chex: func [
    bin [binary! any-string!]
    /local ret c
][
    print ["bin: " mold bin]
    ret: copy ""
    for-each c bin [
        append ret join "\x" skip to-hex to integer! to char! c 6
    ]
    ret
]

EOL: charset [#"^/" #"^M"]

parse cnt [
    some [
        copy temp to "|" (emit rejoin [{^{"} temp {", }]) ;3-letter code
        "|" [copy temp 3 lower (emit rejoin [{"} temp {"}]) | none (emit "NULL")] (emit ", ") ; terminologic
        "|" [copy temp 2 lower (emit rejoin [{"} temp {"}]) | none (emit "NULL")] (emit ", ") ; 2-letter code
        "|" copy temp to "|" (emit rejoin [{"} temp {", }]) ;language name in English
        "|" copy temp to "^/" (emit rejoin [{"} binary-to-chex temp {"^},^/}]) ;lanuage name in french language
        EOL
    ]
]

emit "^};"
